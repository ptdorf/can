#!/usr/bin/env ruby
$LOAD_PATH.unshift File.expand_path(File.dirname(__FILE__)) + "/../lib"

require "thor"
require "can"
require "io/console"
require "json"
require "tablelize"

FILE = "#{ENV['HOME']}/.can"

module Can
  class Cli < Thor
    class_option :password, aliases: "-p"
    class_option :verbose, aliases: "-v", :type => :boolean
    class_option :file, aliases: "-f"

    desc "version", "Show the current version"
    def version
      puts VERSION
    end

    desc "ls [TAG]", "Lists all keys (filter optionally by TAG)"
    # option :values, :type => :boolean
    option :short, :type => :boolean, aliases: "-s"
    def ls(tag=nil)
      init
      rows = [["KEY", "LENGTH", "CREATED", "TAGS"]]

      @can.all().each do |key, entry|
        next if tag and (not entry["tags"] or not entry["tags"].include?(tag))
        if options[:short]
          puts key
          next
        end

        if entry.class == Hash
          value = entry["value"]
          created = entry["created"]
          entry["tags"] = entry["tags"] || []
          tags = entry["tags"].join(" ")
        else
          value = entry
          created = ""
          tags = ""
        end

        rows << [key, value.size, created, tags]
        # if options[:values]
        #   rows << [key, value, created, tags]
        # else
        #   rows << [key, value.size, created, tags]
        # end
      end

      Tablelize::table(rows) if not options[:short]
    end

    desc "get KEY", "Copies a KEY to the clipboard"
    def get(key)
      init
      entry = @can.get(key) or abort "Key #{key} does not exist."
      copy(val(entry))
      puts "Key #{key} was copied to the clipboard."
    end

    desc "rename KEY NEW_NAME", "Renames a secret"
    def rename(key, new_name)
      init
      entry = @can.get(key) or abort "Key #{key} does not exist."
      @can.set new_name, val(entry)
      @can.remove key
      puts "Key #{key} was renamed to #{new_name}."
    end

    desc "password", "Change the can password"
    def password
      init
      pass1 = ask("New password: ")
      pass2 = ask("Confirm password: ")
      if pass1 != pass2
        puts "Passwords don't match."
        abort
      end
      @can.password pass
      puts "Can password was changed."
    end

    desc "set KEY [VALUE]", "Stores a value (empty VALUE show the prompt; use '@random' for a random value)"
    def set(key, value=nil)
      init
      clipboard = false
      if value == "@random"
        clipboard = true
        value = random(60, true)
      end
      value = value || ask("Value: ")
      @can.set key, value
      if clipboard
        copy(value)
        puts "Key #{key} was stored and copied to the clipboard."
      else
        puts "Key #{key} was stored."
      end
    end

    desc "rm KEY", "Removes a key"
    def rm(key)
      init
      @can.exists(key) or abort "Key #{key} does not exist."
      @can.remove key
      puts "Key #{key} was deleted."
    end

    desc "tag KEY TAG", "Tags a key"
    def tag(key, tag)
      init
      @can.exists(key) or abort "Key #{key} does not exist."
      ok = @can.tag(key, tag)
      puts "Tag #{tag} was added to #{key}." if ok
      puts "Tag #{tag} already exists on #{key}." unless ok
    end

    desc "tags [KEY]", "Show all tags (filter for a key)"
    def tags(key=nil)
      init
      if key
        @can.exists(key) or abort "Key #{key} does not exist."
        entry = @can.get(key)
        tags = entry["tags"] || []
      else
        tags = []
        @can.all().each do |key, entry|
          entry["tags"] = entry["tags"] || []
          tags = tags | entry["tags"]
        end
      end

      puts tags.uniq.join("\n")
    end

    desc "untag KEY TAG", "Untags a tag from a key"
    def untag(key, tag)
      init
      @can.exists(key) or abort "Key #{key} does not exist."
      ok = @can.untag(key, tag)
      puts "Tag #{tag} was removed from #{key}." if ok
      puts "Tag #{tag} doesn't exist on #{key}." unless ok
    end

    desc "migrate", "Migrates to new format"
    def migrate()
      init
      count = @can.migrate()
      puts "Keys migrated: #{count}."
    end

    desc "encrypt DATA", "Encrypts data"
    def encrypt(data)
      init
      puts @can.encrypt(data)
    end

    desc "decrypt DATA", "Decrypts data"
    def decrypt(data)
      init
      puts @can.decrypt(data)
    end

    desc "random [LENGTH]", "Generates a random password"
    option :symbols, :type => :boolean, aliases: "-s"
    def random(length=60, capture=false)
      info
      length  = length.to_i
      chars   = ("0".."9").to_a + ("A".."Z").to_a + ("a".."z").to_a
      chars  += ("!".."?").to_a if options[:symbols]
      chars.delete(["'", '"'])
      # pass = chars.sort_by { rand }.join[0...length]
      pass = []
      (1 .. length).each do
        pass << chars[rand(chars.size)]
      end
      pass = pass.join()
      return pass if capture
      puts pass
    end

    private
    def __method_missing name, *args
      name  = name.to_s
      value = args[0]
      if value
        set name, value
      else
        get name
      end
    end

    def info()
      debug "Can version: #{VERSION}"
      debug "Using verbose mode (goes to stderr)"
      debug "Using file #{@file}"
      debug "Using options #{options}"
    end

    def init()
      @file = options[:file] || ENV.fetch("CAN_FILE", nil) || FILE
      info()

      return if check(options[:password], "options")
      return if check(ENV.fetch("CAN_PASSWORD", nil), "environment")
      return if check(ask(), "prompt")
      abort
    end

    def check(password, source)
      return if not password or password.length < 1

      @can = Can::Store.new(@file, password)
      begin
        @can.all()
        debug "Opened with password from #{source}"
        debug "Can format: v#{@can.format()}"
        return true
      rescue
        debug "Failed to open with password from #{source}"
        abort "Wrong password"
      end
    end

    def val(value)
      return value["value"] if value.class == Hash
      value
    end

    def ask(prompt = "Password: ")
      begin
        print prompt
        answer = STDIN.noecho(&:gets).chomp
        raise Interrupt if answer.length < 1
        puts
        answer
      rescue Interrupt
        puts
        debug "Password prompt cancelled"
        abort
      end
    end

    def debug(message)
      return if not options[:verbose]
      STDERR.puts "\033[38;5;240m#{message}\033[0m"
    end

    def copy(value)
      IO.popen("pbcopy", "w") { |cc| cc.write(value) }
      value
    end

  end
end

Can::Cli.start ARGV
